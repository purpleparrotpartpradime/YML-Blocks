<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ActionStack IDE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* Minimal Tailwind CSS subset with responsive utilities */
        .flex { display: flex; }
        .flex-1 { flex: 1 1 0%; }
        .flex-col { flex-direction: column; }
        .flex-row { flex-direction: row; }
        .justify-between { justify-content: space-between; }
        .items-center { align-items: center; }
        .space-x-2 > * + * { margin-left: 0.5rem; }
        .space-x-1 > * + * { margin-left: 0.25rem; }
        .space-y-2 > * + * { margin-top: 0.5rem; }
        .h-screen { height: 100vh; }
        .w-64 { width: 16rem; }
        .w-full { width: 100%; }
        .w-[120px] { width: 120px; }
        .h-10 { height: 2.5rem; }
        .max-w-[280px] { max-width: 280px; }
        .max-h-[80vh] { max-height: 80vh; }
        .p-4 { padding: 1rem; }
        .p-2 { padding: 0.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mt-2 { margin-top: 0.5rem; }
        .bg-gray-800 { background-color: #1f2937; }
        .bg-gray-700 { background-color: #374151; }
        .bg-blue-600 { background-color: #2563eb; }
        .bg-blue-700 { background-color: #1d4ed8; }
        .bg-opacity-50 { background-color: rgba(0, 0, 0, 0.5); }
        .text-white { color: #ffffff; }
        .text-blue-300 { color: #93c5fd; }
        .text-gray-300 { color: #d1d5db; }
        .text-lg { font-size: 1.125rem; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .rounded { border-radius: 0.25rem; }
        .overflow-y-auto { overflow-y: auto; }
        .hidden { display: none; }
        .cursor-pointer { cursor: pointer; }
        .cursor-move { cursor: move; }
        .cursor-se-resize { cursor: se-resize; }
        .opacity-75 { opacity: 0.75; }
        .hover\:bg-blue-700:hover { background-color: #1d4ed8; }
        .fixed { position: fixed; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .z-20 { z-index: 20; }
        .z-30 { z-index: 30; }
        .sm\:p-4 { padding: 1rem; }
        .sm\:text-lg { font-size: 1.125rem; }
        .sm\:text-sm { font-size: 0.875rem; }
        .sm\:w-64 { width: 16rem; }
        .sm\:flex-row { flex-direction: row; }
        .md\:p-4 { padding: 1rem; }
        .touch-pan-y { touch-action: pan-y; }

        /* Custom styles for the IDE */
        body { background-color: #1a1a1a; color: #e5e7eb; font-family: Arial, sans-serif; margin: 0; }
        #canvas, #html-canvas { border: 1px solid #4b5563; background-color: #2d2d2d; width: 100%; }
        .block { border-radius: 8px; padding: 8px; }
        .toolbar .block { display: flex; align-items: center; justify-content: center; }
        .node { width: 12px; height: 12px; border-radius: 50%; position: absolute; }
        .input-node { background-color: #3b82f6; }
        .output-node { background-color: #ef4444; }
        .toolbar { background-color: #374151; z-index: 30; }
        .tab { background-color: #4b5563; }
        .tab.active { background-color: #3b82f6; }
        .sub-tab { background-color: #4b5563; }
        .sub-tab.active { background-color: #3b82f6; }
        .wire { stroke: #60a5fa; stroke-width: 2; }
        .dropdown { position: absolute; background-color: #374151; border: 1px solid #4b5563; z-index: 40; }
        .dropdown-item { padding: 0.5rem; cursor: pointer; color: #ffffff; }
        .dropdown-item:hover { background-color: #2563eb; }
        .resize-handle { width: 10px; height: 10px; background-color: #ffffff; position: absolute; cursor: se-resize; }
        textarea { background-color: #2d2d2d; color: #e5e7eb; border: 1px solid #4b5563; width: 100%; height: 100%; resize: none; }
        @media (max-width: 640px) {
            .toolbar { position: fixed; top: 0; left: -100%; width: 75%; max-width: 280px; height: 100%; transition: left 0.3s; }
            .toolbar.open { left: 0; }
            .overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); z-index: 20; }
            .canvas-container { margin-left: 0; }
            .node { width: 16px; height: 16px; }
            .block { padding: 6px; }
            .toolbar .block { padding: 8px; }
            #yaml-blocks, #html-elements { max-height: calc(100vh - 50px); }
            #html-code-editor { max-height: calc(100vh - 48px); }
        }
        @media (min-width: 640px) {
            #yaml-blocks, #html-elements, #html-code-editor { max-height: calc(100vh - 80px); }
        }
    </style>
</head>
<body class="flex h-screen flex-col sm:flex-row">
    <button id="toggle-toolbar" class="fixed top-2 left-2 sm:hidden px-2 py-1 bg-blue-600 text-white text-sm rounded z-30">â˜°</button>
    <div id="toolbar" class="toolbar sm:w-64 p-2 sm:p-4 overflow-y-auto touch-pan-y">
        <div class="flex justify-between items-center mb-2">
            <h2 class="text-sm sm:text-lg font-bold text-blue-300">Toolbar</h2>
            <button id="close-toolbar" class="sm:hidden px-2 py-1 bg-blue-600 text-white text-sm rounded hidden">Close</button>
        </div>
        <div id="yaml-blocks" class="mb-4 overflow-y-auto touch-pan-y">
            <h3 class="text-xs sm:text-sm font-semibold text-gray-300">YAML Blocks</h3>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="AND">AND Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="XOR">XOR Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="NOR">NOR Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="EITHER">EITHER Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="MATH">Math Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="VARIABLE">Variable Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CALC_METHOD">Calc Method Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_HTML">Custom HTML Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_JAVA">Custom Java Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_NODEJS">Custom Node.js Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_JS">Custom JS Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_YAML">Custom YAML Block</div>
        </div>
        <div id="html-elements" class="hidden overflow-y-auto touch-pan-y">
            <h3 class="text-xs sm:text-sm font-semibold text-gray-300">HTML Elements</h3>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="DIV">Div Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="BUTTON">Button Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="INPUT">Input Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="P">Paragraph Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="H1">Heading 1 Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="IMG">Image Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="A">Link Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="SPAN">Span Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="UL">Unordered List Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="LI">List Item Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="FORM">Form Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="TEXTAREA">Textarea Element</div>
        </div>
    </div>
    <div id="overlay" class="hidden overlay"></div>
    <div class="flex-1 flex flex-col canvas-container">
        <div class="flex flex-col sm:flex-row justify-between p-2 sm:p-4 bg-gray-800">
            <div class="flex space-x-2">
                <button id="yaml-tab" class="tab px-2 sm:px-4 py-1 sm:py-2 text-white text-xs sm:text-sm active">YAML Editor</button>
                <button id="html-tab" class="tab px-2 sm:px-4 py-1 sm:py-2 text-white text-xs sm:text-sm">HTML Editor</button>
            </div>
            <div class="flex space-x-2 mt-2 sm:mt-0">
                <input id="github-pat" type="password" placeholder="GitHub PAT (expires recommended)" class="px-2 py-1 bg-gray-700 text-white text-xs sm:text-sm rounded w-full sm:w-auto">
                <button id="import-btn" class="px-2 sm:px-4 py-1 sm:py-2 bg-blue-600 text-white text-xs sm:text-sm rounded hover:bg-blue-700">Import</button>
                <button id="export-btn" class="px-2 sm:px-4 py-1 sm:py-2 bg-blue-600 text-white text-xs sm:text-sm rounded hover:bg-blue-700">Export</button>
                <button id="save-btn" class="px-2 sm:px-4 py-1 sm:py-2 bg-blue-600 text-white text-xs sm:text-sm rounded hover:bg-blue-700">Save to GitHub</button>
            </div>
        </div>
        <div id="yaml-editor" class="flex-1 p-2 sm:p-4">
            <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 mb-4">
                <button id="new-tab-btn" class="px-2 py-1 bg-gray-700 text-white text-xs sm:text-sm rounded">New Tab</button>
                <div id="tab-bar" class="flex space-x-1"></div>
            </div>
            <canvas id="canvas"></canvas>
        </div>
        <div id="html-editor" class="flex-1 p-2 sm:p-4 hidden">
            <div class="flex space-x-2 mb-2">
                <button id="visual-sub-tab" class="sub-tab px-2 sm:px-4 py-1 sm:py-2 text-white text-xs sm:text-sm active">Visual Editor</button>
                <button id="code-sub-tab" class="sub-tab px-2 sm:px-4 py-1 sm:py-2 text-white text-xs sm:text-sm">Code Editor</button>
            </div>
            <div id="html-visual-editor" class="flex-1">
                <canvas id="html-canvas"></canvas>
            </div>
            <div id="html-code-editor" class="flex-1 hidden overflow-y-auto touch-pan-y">
                <textarea id="html-code-textarea" class="w-full h-full"></textarea>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas');
            const ctx = canvas?.getContext('2d');
            const htmlCanvas = document.getElementById('html-canvas');
            const htmlCtx = htmlCanvas?.getContext('2d');
            const htmlCodeTextarea = document.getElementById('html-code-textarea');
            let blocks = [];
            let htmlElements = [];
            let wires = [];
            let tabs = [{ name: 'main.yml', blocks: [], wires: [] }];
            let currentTab = 0;
            let draggingBlock = null;
            let draggingWire = null;
            let resizingElement = null;
            let offsetX, offsetY;
            let activeTab = 'yaml';
            let activeHtmlSubTab = 'visual';
            let touchStartTime = 0;

            // Block definitions
            const blockTypes = {
                AND: { inputs: 2, outputs: 1, color: '#4b5563', height: 80 },
                XOR: { inputs: 2, outputs: 1, color: '#4b5563', height: 80 },
                NOR: { inputs: 2, outputs: 1, color: '#4b5563', height: 80 },
                EITHER: { inputs: 2, outputs: 1, color: '#4b5563', height: 80 },
                MATH: { inputs: 3, outputs: 1, color: '#4b5563', height: 100 },
                VARIABLE: { inputs: 1, outputs: 1, color: '#4b5563', height: 60 },
                CALC_METHOD: { inputs: 0, outputs: 1, color: '#4b5563', height: 60 },
                CUSTOM_HTML: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 },
                CUSTOM_JAVA: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 },
                CUSTOM_NODEJS: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 },
                CUSTOM_JS: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 },
                CUSTOM_YAML: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 }
            };

            // Valid operations for CALC_METHOD
            const validMethods = ['add', 'subtract', 'multiply', 'divide'];

            // HTML element types for validation
            const htmlElementTypes = ['DIV', 'BUTTON', 'INPUT', 'P', 'H1', 'IMG', 'A', 'SPAN', 'UL', 'LI', 'FORM', 'TEXTAREA'];

            // Calculate MATH block output
            function calculateMathOutput(block) {
                try {
                    const methodWire = tabs[currentTab].wires.find(w => w.to.block.id === block.id && w.to.index === 0);
                    const input1Wire = tabs[currentTab].wires.find(w => w.to.block.id === block.id && w.to.index === 1);
                    const input2Wire = tabs[currentTab].wires.find(w => w.to.block.id === block.id && w.to.index === 2);
                    if (!methodWire || !input1Wire || !input2Wire) return null;
                    const methodBlock = methodWire.from.block;
                    const input1Block = input1Wire.from.block;
                    const input2Block = input2Wire.from.block;
                    if (methodBlock.type !== 'CALC_METHOD' || input1Block.type !== 'VARIABLE' || input2Block.type !== 'VARIABLE') return null;
                    const method = methodBlock.value;
                    const val1 = Number(input1Block.value);
                    const val2 = Number(input2Block.value);
                    if (isNaN(val1) || isNaN(val2)) return null;
                    switch (method) {
                        case 'add': return val1 + val2;
                        case 'subtract': return val1 - val2;
                        case 'multiply': return val1 * val2;
                        case 'divide': return val2 !== 0 ? val1 / val2 : null;
                        default: return null;
                    }
                } catch (e) {
                    console.error('Calculate MATH output error:', e);
                    return null;
                }
            }

            // Validate PAT format
            function validatePAT(pat) {
                try {
                    return pat && (pat.startsWith('ghp_') || pat.startsWith('github_pat_')) && (pat.length === 40 || pat.length === 80);
                } catch (e) {
                    console.error('PAT validation error:', e);
                    return false;
                }
            }

            // Generate HTML from htmlElements
            function generateHTML() {
                try {
                    let html = '<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Generated Page</title>\n</head>\n<body>\n';
                    htmlElements.forEach(element => {
                        const style = `position: absolute; left: ${element.x}px; top: ${element.y}px; width: ${element.width}px; height: ${element.height}px; background-color: ${element.backgroundColor};`;
                        if (element.type === 'IMG') {
                            html += `    <${element.type.toLowerCase()} src="${element.content}" style="${style}">\n`;
                        } else if (element.type === 'A') {
                            html += `    <${element.type.toLowerCase()} href="${element.content.href}" style="${style}">${element.content.text}</${element.type.toLowerCase()}>\n`;
                        } else {
                            html += `    <${element.type.toLowerCase()} style="${style}">${element.content}</${element.type.toLowerCase()}>\n`;
                        }
                    });
                    html += '</body>\n</html>';
                    return html;
                } catch (e) {
                    console.error('Generate HTML error:', e);
                    return '';
                }
            }

            // Generate files for export/save
            function generateFiles() {
                try {
                    const files = {};
                    tabs.forEach((tab, index) => {
                        const yamlContent = generateYAML(tab);
                        files[tab.name] = yamlContent;
                    });
                    files['index.html'] = generateHTML();
                    return files;
                } catch (e) {
                    console.error('Generate files error:', e);
                    return {};
                }
            }

            // Generate YAML for a tab
            function generateYAML(tab) {
                try {
                    let yaml = `name: ${tab.name.replace('.yml', '')}\nsteps:\n`;
                    tab.blocks.forEach(block => {
                        yaml += `  - id: ${block.id}\n    type: ${block.type}\n    x: ${block.x}\n    y: ${block.y}\n`;
                        if (block.type === 'VARIABLE' || block.type === 'CALC_METHOD') {
                            yaml += `    value: ${block.value}\n`;
                        }
                    });
                    yaml += 'wires:\n';
                    tab.wires.forEach(wire => {
                        yaml += `  - from: ${wire.from.block.id}:${wire.from.index}\n    to: ${wire.to.block.id}:${wire.to.index}\n`;
                    });
                    return yaml;
                } catch (e) {
                    console.error('Generate YAML error:', e);
                    return '';
                }
            }

            // Responsive canvas sizing
            function resizeCanvases() {
                try {
                    const container = document.querySelector('.canvas-container');
                    if (!container || !canvas || !htmlCanvas) return;
                    const width = container.clientWidth - (window.innerWidth < 640 ? 16 : 32);
                    const height = container.clientHeight - (window.innerWidth < 640 ? 150 : 100);
                    canvas.width = width;
                    canvas.height = height;
                    htmlCanvas.width = width;
                    htmlCanvas.height = height;
                    draw();
                    drawHtmlCanvas();
                } catch (e) {
                    console.error('Canvas resize error:', e);
                }
            }

            window.addEventListener('resize', resizeCanvases);
            resizeCanvases();

            // Toolbar toggle for mobile
            const toolbar = document.getElementById('toolbar');
            const toggleToolbarBtn = document.getElementById('toggle-toolbar');
            const closeToolbarBtn = document.getElementById('close-toolbar');
            const overlay = document.getElementById('overlay');

            function closeToolbar() {
                try {
                    if (toolbar && closeToolbarBtn && toggleToolbarBtn && overlay) {
                        toolbar.classList.remove('open');
                        closeToolbarBtn.classList.add('hidden');
                        toggleToolbarBtn.classList.remove('hidden');
                        overlay.classList.add('hidden');
                    }
                } catch (e) {
                    console.error('Close toolbar error:', e);
                }
            }

            if (toggleToolbarBtn) {
                toggleToolbarBtn.addEventListener('click', () => {
                    try {
                        toolbar.classList.add('open');
                        closeToolbarBtn.classList.remove('hidden');
                        toggleToolbarBtn.classList.add('hidden');
                        overlay.classList.remove('hidden');
                    } catch (e) {
                        console.error('Toggle toolbar error:', e);
                    }
                });
            }

            if (closeToolbarBtn) {
                closeToolbarBtn.addEventListener('click', closeToolbar);
            }

            if (overlay) {
                overlay.addEventListener('click', closeToolbar);
            }

            // Initialize toolbar block events
            document.querySelectorAll('.block').forEach(block => {
                block.addEventListener('dragstart', (e) => {
                    try {
                        e.dataTransfer.setData('type', block.dataset.type);
                        block.classList.add('opacity-75');
                        if (window.innerWidth < 640) closeToolbar();
                    } catch (e) {
                        console.error('Block dragstart error:', e);
                    }
                });
                block.addEventListener('dragend', () => {
                    try {
                        block.classList.remove('opacity-75');
                    } catch (e) {
                        console.error('Block dragend error:', e);
                    }
                });
                block.addEventListener('touchstart', (e) => {
                    try {
                        touchStartTime = Date.now();
                    } catch (e) {
                        console.error('Block touchstart error:', e);
                    }
                });
                block.addEventListener('touchend', (e) => {
                    try {
                        if (Date.now() - touchStartTime < 300 && !block.classList.contains('opacity-75')) {
                            block.click();
                        }
                    } catch (e) {
                        console.error('Block touchend error:', e);
                    }
                });
                block.addEventListener('click', () => {
                    try {
                        const type = block.dataset.type;
                        const targetCanvas = activeTab === 'yaml' ? canvas : htmlCanvas;
                        if (!targetCanvas) return;
                        const blockWidth = activeTab === 'yaml' ? (window.innerWidth < 640 ? 150 : 200) : (window.innerWidth < 640 ? 100 : 150);
                        const blockHeight = activeTab === 'yaml' ? blockTypes[type]?.height || 60 : 50;
                        const x = targetCanvas.width / 2 - blockWidth / 2;
                        const y = targetCanvas.height / 2 - blockHeight / 2;
                        if (activeTab === 'yaml' && blockTypes[type]) {
                            const newBlock = {
                                id: Date.now(),
                                type,
                                x,
                                y,
                                inputs: blockTypes[type].inputs,
                                outputs: blockTypes[type].outputs,
                                value: type === 'VARIABLE' ? 0 : (type === 'CALC_METHOD' ? 'add' : ''),
                                htmlElement: null
                            };
                            tabs[currentTab].blocks.push(newBlock);
                            draw();
                        } else if (activeTab === 'html' && htmlElementTypes.includes(type)) {
                            const element = {
                                id: Date.now(),
                                type,
                                x,
                                y,
                                width: blockWidth,
                                height: blockHeight,
                                backgroundColor: '#4b5563',
                                content: type === 'IMG' ? 'image.png' : type === 'A' ? { text: 'Link', href: '#' } : type.toLowerCase()
                            };
                            htmlElements.push(element);
                            updateHtmlCodeEditor();
                            drawHtmlCanvas();
                        }
                        if (window.innerWidth < 640) closeToolbar();
                    } catch (e) {
                        console.error('Block click error:', e);
                        alert('Failed to add block: ' + e.message);
                    }
                });
            });

            // Canvas drag-and-drop
            function getCanvasPosition(e, canvas, isTouch = false) {
                try {
                    if (!canvas) return { x: 0, y: 0 };
                    const rect = canvas.getBoundingClientRect();
                    const clientX = isTouch ? (e.touches?.[0]?.clientX || e.changedTouches?.[0]?.clientX || e.clientX || 0) : e.clientX;
                    const clientY = isTouch ? (e.touches?.[0]?.clientY || e.changedTouches?.[0]?.clientY || e.clientY || 0) : e.clientY;
                    return { x: clientX - rect.left, y: clientY - rect.top };
                } catch (e) {
                    console.error('getCanvasPosition error:', e);
                    return { x: 0, y: 0 };
                }
            }

            if (canvas) {
                canvas.addEventListener('dragover', (e) => e.preventDefault());
                canvas.addEventListener('drop', (e) => {
                    try {
                        e.preventDefault();
                        const type = e.dataTransfer.getData('type');
                        if (blockTypes[type]) {
                            const { x, y } = getCanvasPosition(e, canvas);
                            const block = {
                                id: Date.now(),
                                type,
                                x,
                                y,
                                inputs: blockTypes[type].inputs,
                                outputs: blockTypes[type].outputs,
                                value: type === 'VARIABLE' ? 0 : (type === 'CALC_METHOD' ? 'add' : ''),
                                htmlElement: null
                            };
                            tabs[currentTab].blocks.push(block);
                            draw();
                        }
                    } catch (e) {
                        console.error('Canvas drop error:', e);
                        alert('Failed to drop block: ' + e.message);
                    }
                });
            }

            if (htmlCanvas) {
                htmlCanvas.addEventListener('dragover', (e) => e.preventDefault());
                htmlCanvas.addEventListener('drop', (e) => {
                    try {
                        e.preventDefault();
                        const type = e.dataTransfer.getData('type');
                        if (htmlElementTypes.includes(type)) {
                            const { x, y } = getCanvasPosition(e, htmlCanvas);
                            const blockWidth = window.innerWidth < 640 ? 100 : 150;
                            const blockHeight = 50;
                            const element = {
                                id: Date.now(),
                                type,
                                x,
                                y,
                                width: blockWidth,
                                height: blockHeight,
                                backgroundColor: '#4b5563',
                                content: type === 'IMG' ? 'image.png' : type === 'A' ? { text: 'Link', href: '#' } : type.toLowerCase()
                            };
                            htmlElements.push(element);
                            updateHtmlCodeEditor();
                            drawHtmlCanvas();
                        }
                    } catch (e) {
                        console.error('HTML canvas drop error:', e);
                        alert('Failed to drop element: ' + e.message);
                    }
                });
            }

            // Edit CALC_METHOD block
            function showMethodDropdown(block, x, y) {
                try {
                    const existingDropdown = document.querySelector('.dropdown');
                    if (existingDropdown) existingDropdown.remove();
                    const dropdown = document.createElement('div');
                    dropdown.className = 'dropdown';
                    dropdown.style.left = `${x}px`;
                    dropdown.style.top = `${y}px`;
                    validMethods.forEach(method => {
                        const item = document.createElement('div');
                        item.className = 'dropdown-item';
                        item.textContent = method;
                        item.addEventListener('click', () => {
                            try {
                                block.value = method;
                                dropdown.remove();
                                draw();
                            } catch (e) {
                                console.error('Dropdown select error:', e);
                                alert('Failed to select method: ' + e.message);
                            }
                        });
                        dropdown.appendChild(item);
                    });
                    document.body.appendChild(dropdown);
                } catch (e) {
                    console.error('Show dropdown error:', e);
                    alert('Failed to show dropdown: ' + e.message);
                }
            }

            // Edit HTML element content
            function editHtmlElement(element) {
                try {
                    if (element.type === 'IMG') {
                        const src = prompt('Enter image source URL:', element.content);
                        if (src && /^https?:\/\/.+$/.test(src)) {
                            element.content = src;
                        } else if (src) {
                            alert('Invalid URL. Must start with http:// or https://');
                            return;
                        }
                    } else if (element.type === 'A') {
                        const text = prompt('Enter link text:', element.content.text);
                        const href = prompt('Enter link URL:', element.content.href);
                        if (text && href && /^https?:\/\/.+$/.test(href)) {
                            element.content = { text, href };
                        } else if (href && !/^https?:\/\/.+$/.test(href)) {
                            alert('Invalid URL. Must start with http:// or https://');
                            return;
                        }
                    } else {
                        const content = prompt(`Enter content for ${element.type.toLowerCase()}:`, element.content);
                        if (content) element.content = content;
                    }
                    updateHtmlCodeEditor();
                    drawHtmlCanvas();
                } catch (e) {
                    console.error('Edit HTML element error:', e);
                    alert('Failed to edit element: ' + e.message);
                }
            }

            // Mouse and touch events for dragging blocks, wires, and resizing
            function handleStart(e, isTouch = false) {
                try {
                    if (isTouch && !e.touches?.length) return;
                    const { x, y } = getCanvasPosition(isTouch ? e : e, activeTab === 'yaml' ? canvas : htmlCanvas, isTouch);
                    if (activeTab === 'yaml') {
                        for (let block of tabs[currentTab].blocks) {
                            const blockWidth = window.innerWidth < 640 ? 150 : 200;
                            const blockHeight = blockTypes[block.type]?.height || 60;
                            if (x >= block.x && x <= block.x + blockWidth && y >= block.y && y <= block.y + blockHeight) {
                                const node = getNode(block, x, y);
                                if (node) {
                                    draggingWire = { block, node };
                                    return;
                                }
                                draggingBlock = block;
                                offsetX = x - block.x;
                                offsetY = y - block.y;
                                break;
                            }
                        }
                    } else if (activeTab === 'html' && activeHtmlSubTab === 'visual') {
                        for (let element of htmlElements) {
                            if (x >= element.x && x <= element.x + element.width && y >= element.y && y <= element.y + element.height) {
                                const resizeHandleSize = 10;
                                if (x >= element.x + element.width - resizeHandleSize && y >= element.y + element.height - resizeHandleSize) {
                                    resizingElement = element;
                                    offsetX = x - element.width;
                                    offsetY = y - element.height;
                                } else {
                                    draggingBlock = element;
                                    offsetX = x - element.x;
                                    offsetY = y - element.y;
                                }
                                break;
                            }
                        }
                    }
                } catch (e) {
                    console.error('Handle start error:', e);
                }
            }

            function handleMove(e, isTouch = false) {
                try {
                    if (isTouch && !e.touches?.length) return;
                    const { x, y } = getCanvasPosition(isTouch ? e : e, activeTab === 'yaml' ? canvas : htmlCanvas, isTouch);
                    if (draggingBlock) {
                        const snapDistance = window.innerWidth < 640 ? 30 : 25;
                        draggingBlock.x = Math.round((x - offsetX) / snapDistance) * snapDistance;
                        draggingBlock.y = Math.round((y - offsetY) / snapDistance) * snapDistance;
                        if (activeTab === 'html') updateHtmlCodeEditor();
                        activeTab === 'yaml' ? draw() : drawHtmlCanvas();
                    } else if (resizingElement) {
                        resizingElement.width = Math.max(50, Math.round((x - resizingElement.x - offsetX) / 10) * 10);
                        resizingElement.height = Math.max(50, Math.round((y - resizingElement.y - offsetY) / 10) * 10);
                        updateHtmlCodeEditor();
                        drawHtmlCanvas();
                    } else if (draggingWire && ctx) {
                        draw();
                        ctx.beginPath();
                        ctx.moveTo(draggingWire.node.x, draggingWire.node.y);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = '#60a5fa';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                } catch (e) {
                    console.error('Handle move error:', e);
                }
            }

            function handleEnd(e, isTouch = false) {
                try {
                    if (draggingWire) {
                        const { x, y } = getCanvasPosition(isTouch ? (e.changedTouches?.[0] || e) : e, canvas, isTouch);
                        let closestNode = null;
                        let minDistance = Infinity;
                        let targetBlock = null;
                        for (let block of tabs[currentTab].blocks) {
                            if (block !== draggingWire.block) {
                                const node = getNode(block, x, y, true);
                                if (node && node.type === 'input') {
                                    const distance = Math.hypot(x - node.x, y - node.y);
                                    if (distance < minDistance) {
                                        minDistance = distance;
                                        closestNode = node;
                                        targetBlock = block;
                                    }
                                }
                            }
                        }
                        const maxDistance = window.innerWidth < 640 ? 30 : 25;
                        if (closestNode && targetBlock && draggingWire.node.type === 'output' && minDistance < maxDistance) {
                            if (targetBlock.type === 'MATH' && closestNode.index === 0 && draggingWire.block.type !== 'CALC_METHOD') {
                                alert(`Invalid connection: MATH block input 0 requires CALC_METHOD, got ${draggingWire.block.type}`);
                            } else if (targetBlock.type === 'MATH' && closestNode.index > 0 && draggingWire.block.type !== 'VARIABLE') {
                                alert(`Invalid connection: MATH block inputs 1 and 2 require VARIABLE, got ${draggingWire.block.type}`);
                            } else {
                                tabs[currentTab].wires.push({
                                    from: { block: draggingWire.block, index: draggingWire.node.index },
                                    to: { block: targetBlock, index: closestNode.index }
                                });
                            }
                        }
                        draggingWire = null;
                        draw();
                    }
                    draggingBlock = null;
                    resizingElement = null;
                } catch (e) {
                    console.error('Handle end error:', e);
                }
            }

            if (canvas) {
                canvas.addEventListener('mousedown', handleStart);
                canvas.addEventListener('mousemove', handleMove);
                canvas.addEventListener('mouseup', handleEnd);
                canvas.addEventListener('touchstart', (e) => handleStart(e, true));
                canvas.addEventListener('touchmove', (e) => handleMove(e, true));
                canvas.addEventListener('touchend', (e) => {
                    try {
                        if (Date.now() - touchStartTime < 300 && !draggingWire && !draggingBlock) {
                            return;
                        }
                        handleEnd(e, true);
                    } catch (e) {
                        console.error('Canvas touchend error:', e);
                    }
                });
                canvas.addEventListener('dblclick', (e) => {
                    try {
                        const { x, y } = getCanvasPosition(e, canvas);
                        for (let block of tabs[currentTab].blocks) {
                            const blockWidth = window.innerWidth < 640 ? 150 : 200;
                            const blockHeight = blockTypes[block.type]?.height || 60;
                            if (x >= block.x && x <= block.x + blockWidth && y >= block.y && y <= block.y + blockHeight) {
                                if (block.type === 'CALC_METHOD') {
                                    showMethodDropdown(block, e.clientX, e.clientY);
                                } else if (block.type === 'VARIABLE') {
                                    const value = prompt('Enter variable value:', block.value);
                                    if (value && !isNaN(value)) {
                                        block.value = Number(value);
                                        draw();
                                    } else if (value) {
                                        alert('Invalid value: must be a number.');
                                    }
                                }
                                break;
                            }
                        }
                    } catch (e) {
                        console.error('Canvas dblclick error:', e);
                        alert('Failed to edit block: ' + e.message);
                    }
                });
            }

            if (htmlCanvas) {
                htmlCanvas.addEventListener('mousedown', handleStart);
                htmlCanvas.addEventListener('mousemove', handleMove);
                htmlCanvas.addEventListener('mouseup', handleEnd);
                htmlCanvas.addEventListener('touchstart', (e) => handleStart(e, true));
                htmlCanvas.addEventListener('touchmove', (e) => handleMove(e, true));
                htmlCanvas.addEventListener('touchend', (e) => {
                    try {
                        if (Date.now() - touchStartTime < 300 && !draggingBlock && !resizingElement) {
                            return;
                        }
                        handleEnd(e, true);
                    } catch (e) {
                        console.error('HTML canvas touchend error:', e);
                    }
                });
                htmlCanvas.addEventListener('click', (e) => {
                    try {
                        const { x, y } = getCanvasPosition(e, htmlCanvas);
                        for (let element of htmlElements) {
                            if (x >= element.x && x <= element.x + element.width && y >= element.y && y <= element.y + element.height) {
                                const colorPicker = document.createElement('input');
                                colorPicker.type = 'color';
                                colorPicker.value = element.backgroundColor;
                                colorPicker.style.position = 'absolute';
                                colorPicker.style.left = `${e.clientX}px`;
                                colorPicker.style.top = `${e.clientY}px`;
                                colorPicker.style.zIndex = '40';
                                colorPicker.addEventListener('change', () => {
                                    element.backgroundColor = colorPicker.value;
                                    updateHtmlCodeEditor();
                                    drawHtmlCanvas();
                                    colorPicker.remove();
                                });
                                document.body.appendChild(colorPicker);
                                colorPicker.click();
                                break;
                            }
                        }
                    } catch (e) {
                        console.error('HTML canvas click error:', e);
                        alert('Failed to change color: ' + e.message);
                    }
                });
                htmlCanvas.addEventListener('dblclick', (e) => {
                    try {
                        const { x, y } = getCanvasPosition(e, htmlCanvas);
                        for (let element of htmlElements) {
                            if (x >= element.x && x <= element.x + element.width && y >= element.y && y <= element.y + element.height) {
                                editHtmlElement(element);
                                break;
                            }
                        }
                    } catch (e) {
                        console.error('HTML canvas dblclick error:', e);
                        alert('Failed to edit element: ' + e.message);
                    }
                });
            }

            function getNode(block, x, y, inputOnly = false) {
                try {
                    if (!block) return null;
                    const nodeSize = window.innerWidth < 640 ? 10 : 8;
                    const hitbox = window.innerWidth < 640 ? 30 : 25;
                    for (let i = 0; i < block.inputs; i++) {
                        const nodeX = block.x;
                        const nodeY = block.y + 20 + (block.type === 'MATH' && i === 0 ? blockTypes[block.type].height / 2 : i * 30);
                        if (Math.hypot(x - nodeX, y - nodeY) < hitbox) {
                            return { x: nodeX, y: nodeY, type: 'input', index: i };
                        }
                    }
                    if (!inputOnly) {
                        for (let i = 0; i < block.outputs; i++) {
                            const nodeX = block.x + (window.innerWidth < 640 ? 150 : 200);
                            const nodeY = block.y + 20 + i * 30;
                            if (Math.hypot(x - nodeX, y - nodeY) < hitbox) {
                                return { x: nodeX, y: nodeY, type: 'output', index: i };
                            }
                        }
                    }
                    return null;
                } catch (e) {
                    console.error('getNode error:', e);
                    return null;
                }
            }

            function draw() {
                try {
                    if (!ctx || !canvas) return;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const blockWidth = window.innerWidth < 640 ? 150 : 200;
                    // Draw wires
                    for (let wire of tabs[currentTab].wires) {
                        const fromNodeX = wire.from.block.x + blockWidth;
                        const fromNodeY = wire.from.block.y + 20 + wire.from.index * 30;
                        const toNodeX = wire.to.block.x;
                        const toNodeY = wire.to.block.y + 20 + (wire.to.block.type === 'MATH' && wire.to.index === 0 ? blockTypes[wire.to.block.type].height / 2 : wire.to.index * 30);
                        ctx.beginPath();
                        ctx.moveTo(fromNodeX, fromNodeY);
                        ctx.lineTo(toNodeX, toNodeY);
                        ctx.strokeStyle = '#60a5fa';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    // Draw blocks
                    for (let block of tabs[currentTab].blocks) {
                        ctx.fillStyle = blockTypes[block.type]?.color || '#4b5563';
                        ctx.fillRect(block.x, block.y, blockWidth, blockTypes[block.type]?.height || 60);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = window.innerWidth < 640 ? '12px Arial' : '14px Arial';
                        ctx.fillText(block.type, block.x + 10, block.y + 20);
                        if (block.type === 'VARIABLE') {
                            ctx.fillText(`Value: ${block.value}`, block.x + 10, block.y + 40);
                        } else if (block.type === 'CALC_METHOD') {
                            ctx.fillText(`Method: ${block.value}`, block.x + 10, block.y + 40);
                        } else if (block.type === 'MATH') {
                            const methodWire = tabs[currentTab].wires.find(w => w.to.block.id === block.id && w.to.index === 0);
                            const input1Wire = tabs[currentTab].wires.find(w => w.to.block.id === block.id && w.to.index === 1);
                            const input2Wire = tabs[currentTab].wires.find(w => w.to.block.id === block.id && w.to.index === 2);
                            const method = methodWire ? tabs[currentTab].blocks.find(b => b.id === methodWire.from.block.id)?.value || 'None' : 'None';
                            const input1 = input1Wire ? tabs[currentTab].blocks.find(b => b.id === input1Wire.from.block.id)?.value || 'None' : 'None';
                            const input2 = input2Wire ? tabs[currentTab].blocks.find(b => b.id === input2Wire.from.block.id)?.value || 'None' : 'None';
                            const output = calculateMathOutput(block);
                            ctx.fillText(`Method: ${method}`, block.x + 10, block.y + 40);
                            ctx.fillText(`Input1: ${input1}`, block.x + 10, block.y + 60);
                            ctx.fillText(`Input2: ${input2}`, block.x + 10, block.y + 80);
                            ctx.fillText(`Output: ${output !== null ? output : 'None'}`, block.x + 10, block.y + 100);
                        }
                        // Draw input nodes
                        for (let i = 0; i < block.inputs; i++) {
                            ctx.beginPath();
                            const nodeY = block.y + 20 + (block.type === 'MATH' && i === 0 ? blockTypes[block.type].height / 2 : i * 30);
                            ctx.arc(block.x, nodeY, window.innerWidth < 640 ? 10 : 8, 0, Math.PI * 2);
                            ctx.fillStyle = '#3b82f6';
                            ctx.fill();
                        }
                        // Draw output nodes
                        for (let i = 0; i < block.outputs; i++) {
                            ctx.beginPath();
                            ctx.arc(block.x + blockWidth, block.y + 20 + i * 30, window.innerWidth < 640 ? 10 : 8, 0, Math.PI * 2);
                            ctx.fillStyle = '#ef4444';
                            ctx.fill();
                        }
                    }
                } catch (e) {
                    console.error('Draw error:', e);
                }
            }

            function drawHtmlCanvas() {
                try {
                    if (!htmlCtx || !htmlCanvas || activeHtmlSubTab !== 'visual') return;
                    htmlCtx.clearRect(0, 0, htmlCanvas.width, htmlCanvas.height);
                    for (let element of htmlElements) {
                        htmlCtx.fillStyle = element.backgroundColor || '#4b5563';
                        htmlCtx.fillRect(element.x, element.y, element.width, element.height);
                        htmlCtx.fillStyle = '#ffffff';
                        htmlCtx.font = window.innerWidth < 640 ? '12px Arial' : '14px Arial';
                        let displayText = element.type;
                        if (element.type === 'IMG') displayText += ` (src: ${element.content})`;
                        else if (element.type === 'A') displayText = `Link (href: ${element.content.href})`;
                        else displayText = element.content;
                        htmlCtx.fillText(displayText, element.x + 10, element.y + 30);
                        // Draw resize handle
                        htmlCtx.fillStyle = '#ffffff';
                        htmlCtx.fillRect(element.x + element.width - 10, element.y + element.height - 10, 10, 10);
                    }
                } catch (e) {
                    console.error('Draw HTML canvas error:', e);
                }
            }

            // Update Code Editor textarea
            function updateHtmlCodeEditor() {
                try {
                    if (htmlCodeTextarea) {
                        htmlCodeTextarea.value = generateHTML();
                    }
                } catch (e) {
                    console.error('Update HTML code editor error:', e);
                }
            }

            // Parse HTML from Code Editor
            function parseHtmlCode() {
                try {
                    const html = htmlCodeTextarea.value;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    if (doc.querySelector('parsererror')) {
                        alert('Invalid HTML code: parsing error.');
                        return;
                    }
                    const body = doc.body;
                    const newElements = [];
                    const blockWidth = window.innerWidth < 640 ? 100 : 150;
                    const blockHeight = 50;
                    let yOffset = 20;
                    function processNode(node, depth = 0) {
                        if (node.nodeType === Node.ELEMENT_NODE && htmlElementTypes.includes(node.tagName)) {
                            const style = node.style;
                            const width = parseInt(style.width) || blockWidth;
                            const height = parseInt(style.height) || blockHeight;
                            const backgroundColor = style.backgroundColor || '#4b5563';
                            const x = parseInt(style.left) || 20;
                            const y = parseInt(style.top) || yOffset;
                            const element = {
                                id: Date.now() + Math.random(),
                                type: node.tagName,
                                x,
                                y,
                                width: Math.max(50, width),
                                height: Math.max(50, height),
                                backgroundColor,
                                content: node.tagName === 'IMG' ? node.src || 'image.png' :
                                         node.tagName === 'A' ? { text: node.textContent || 'Link', href: node.href || '#' } :
                                         node.textContent || node.tagName.toLowerCase()
                            };
                            newElements.push(element);
                            yOffset += height + 20;
                        }
                        node.childNodes.forEach(child => processNode(child, depth + 1));
                    }
                    body.childNodes.forEach(node => processNode(node));
                    htmlElements = newElements;
                    drawHtmlCanvas();
                } catch (e) {
                    console.error('Parse HTML code error:', e);
                    alert('Invalid HTML code: ' + e.message);
                }
            }

            // Tab switching
            function switchToYamlTab() {
                try {
                    activeTab = 'yaml';
                    document.getElementById('yaml-editor')?.classList.remove('hidden');
                    document.getElementById('html-editor')?.classList.add('hidden');
                    document.getElementById('yaml-blocks')?.classList.remove('hidden');
                    document.getElementById('html-elements')?.classList.add('hidden');
                    document.getElementById('yaml-tab')?.classList.add('active');
                    document.getElementById('html-tab')?.classList.remove('active');
                    if (window.innerWidth < 640) closeToolbar();
                    draw();
                } catch (e) {
                    console.error('Switch to YAML tab error:', e);
                    alert('Failed to switch to YAML tab: ' + e.message);
                }
            }

            function switchToHtmlTab() {
                try {
                    activeTab = 'html';
                    document.getElementById('yaml-editor')?.classList.add('hidden');
                    document.getElementById('html-editor')?.classList.remove('hidden');
                    document.getElementById('yaml-blocks')?.classList.add('hidden');
                    document.getElementById('html-elements')?.classList.remove('hidden');
                    document.getElementById('yaml-tab')?.classList.remove('active');
                    document.getElementById('html-tab')?.classList.add('active');
                    if (window.innerWidth < 640) closeToolbar();
                    updateHtmlCodeEditor();
                    drawHtmlCanvas();
                } catch (e) {
                    console.error('Switch to HTML tab error:', e);
                    alert('Failed to switch to HTML tab: ' + e.message);
                }
            }

            function switchToVisualSubTab() {
                try {
                    activeHtmlSubTab = 'visual';
                    document.getElementById('html-visual-editor')?.classList.remove('hidden');
                    document.getElementById('html-code-editor')?.classList.add('hidden');
                    document.getElementById('visual-sub-tab')?.classList.add('active');
                    document.getElementById('code-sub-tab')?.classList.remove('active');
                    drawHtmlCanvas();
                } catch (e) {
                    console.error('Switch to Visual sub-tab error:', e);
                    alert('Failed to switch to Visual Editor: ' + e.message);
                }
            }

            function switchToCodeSubTab() {
                try {
                    activeHtmlSubTab = 'code';
                    document.getElementById('html-visual-editor')?.classList.add('hidden');
                    document.getElementById('html-code-editor')?.classList.remove('hidden');
                    document.getElementById('visual-sub-tab')?.classList.remove('active');
                    document.getElementById('code-sub-tab')?.classList.add('active');
                    updateHtmlCodeEditor();
                } catch (e) {
                    console.error('Switch to Code sub-tab error:', e);
                    alert('Failed to switch to Code Editor: ' + e.message);
                }
            }

            document.getElementById('yaml-tab')?.addEventListener('click', switchToYamlTab);
            document.getElementById('html-tab')?.addEventListener('click', switchToHtmlTab);
            document.getElementById('visual-sub-tab')?.addEventListener('click', switchToVisualSubTab);
            document.getElementById('code-sub-tab')?.addEventListener('click', switchToCodeSubTab);

            // Code Editor input handling
            if (htmlCodeTextarea) {
                htmlCodeTextarea.addEventListener('input', () => {
                    try {
                        parseHtmlCode();
                    } catch (e) {
                        console.error('Code editor input error:', e);
                    }
                });
            }

            // Tab management
            function updateTabs() {
                try {
                    const tabBar = document.getElementById('tab-bar');
                    if (!tabBar) return;
                    tabBar.innerHTML = '';
                    tabs.forEach((tab, index) => {
                        const tabEl = document.createElement('div');
                        tabEl.className = `px-2 py-1 bg-gray-700 text-white text-xs sm:text-sm rounded cursor-pointer ${index === currentTab ? 'bg-blue-600' : ''}`;
                        tabEl.textContent = tab.name;
                        tabEl.addEventListener('click', () => {
                            try {
                                currentTab = index;
                                updateTabs();
                                draw();
                            } catch (e) {
                                console.error('Tab click error:', e);
                                alert('Failed to switch tab: ' + e.message);
                            }
                        });
                        tabBar.appendChild(tabEl);
                    });
                } catch (e) {
                    console.error('Update tabs error:', e);
                }
            }

            document.getElementById('new-tab-btn')?.addEventListener('click', () => {
                try {
                    const name = prompt('Enter tab name:', `file${tabs.length + 1}.yml`);
                    if (name) {
                        tabs.push({ name, blocks: [], wires: [] });
                        currentTab = tabs.length - 1;
                        updateTabs();
                        draw();
                    }
                } catch (e) {
                    console.error('New tab error:', e);
                    alert('Failed to create new tab: ' + e.message);
                }
            });

            // GitHub API functions
            async function saveToGitHub(pat, repo, files, secrets, variables) {
                try {
                    const [owner, repoName] = repo.split('/');
                    if (!owner || !repoName) throw new Error('Invalid repository format. Use owner/repo.');
                    if (!validatePAT(pat)) throw new Error('Invalid PAT format.');

                    const userResponse = await fetch('https://api.github.com/user', {
                        headers: { Authorization: `Bearer ${pat}` }
                    });
                    if (!userResponse.ok) throw new Error('Invalid PAT or insufficient permissions.');

                    for (const [path, content] of Object.entries(files)) {
                        const existingFile = await fetch(`https://api.github.com/repos/${owner}/${repoName}/contents/${path}`, {
                            headers: { Authorization: `Bearer ${pat}`, Accept: 'application/vnd.github.v3+json' }
                        }).catch(() => null);
                        const sha = existingFile?.ok ? (await existingFile.json()).sha : null;
                        await fetch(`https://api.github.com/repos/${owner}/${repoName}/contents/${path}`, {
                            method: sha ? 'PUT' : 'POST',
                            headers: { Authorization: `Bearer ${pat}`, Accept: 'application/vnd.github.v3+json' },
                            body: JSON.stringify({
                                message: `Update ${path} from ActionStack IDE`,
                                content: btoa(unescape(encodeURIComponent(content))),
                                sha
                            })
                        });
                    }

                    for (const [name, value] of Object.entries(secrets)) {
                        const keyResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/actions/secrets/public-key`, {
                            headers: { Authorization: `Bearer ${pat}`, Accept: 'application/vnd.github.v3+json' }
                        });
                        if (!keyResponse.ok) throw new Error('Failed to fetch public key for secrets.');
                        const { key_id, key } = await keyResponse.json();
                        const encryptedValue = await encryptSecret(key, value);
                        await fetch(`https://api.github.com/repos/${owner}/${repoName}/actions/secrets/${name}`, {
                            method: 'PUT',
                            headers: { Authorization: `Bearer ${pat}`, Accept: 'application/vnd.github.v3+json' },
                            body: JSON.stringify({ encrypted_value: encryptedValue, key_id })
                        });
                    }

                    for (const [name, value] of Object.entries(variables)) {
                        await fetch(`https://api.github.com/repos/${owner}/${repoName}/actions/variables/${name}`, {
                            method: 'PUT',
                            headers: { Authorization: `Bearer ${pat}`, Accept: 'application/vnd.github.v3+json' },
                            body: JSON.stringify({ name, value })
                        });
                    }

                    return true;
                } catch (e) {
                    console.error('Save to GitHub error:', e);
                    throw e;
                }
            }

            async function importFromGitHub(pat, repo) {
                try {
                    const [owner, repoName] = repo.split('/');
                    if (!owner || !repoName) throw new Error('Invalid repository format. Use owner/repo.');
                    if (!validatePAT(pat)) throw new Error('Invalid PAT format.');

                    const userResponse = await fetch('https://api.github.com/user', {
                        headers: { Authorization: `Bearer ${pat}` }
                    });
                    if (!userResponse.ok) throw new Error('Invalid PAT or insufficient permissions.');

                    const contents = [];
                    async function fetchContents(path = '') {
                        const response = await fetch(`https://api.github.com/repos/${owner}/${repoName}/contents/${path}`, {
                            headers: { Authorization: `Bearer ${pat}`, Accept: 'application/vnd.github.v3+json' }
                        });
                        if (!response.ok) throw new Error(`Failed to fetch contents at ${path}.`);
                        const items = await response.json();
                        for (const item of items) {
                            if (item.type === 'file') {
                                const fileResponse = await fetch(item.download_url);
                                contents.push({ path: item.path, content: await fileResponse.text() });
                            } else if (item.type === 'dir') {
                                await fetchContents(item.path);
                            }
                        }
                    }
                    await fetchContents();

                    const secretsResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/actions/secrets`, {
                        headers: { Authorization: `Bearer ${pat}`, Accept: 'application/vnd.github.v3+json' }
                    });
                    const secretsData = await secretsResponse.json();
                    const secrets = {};
                    for (const secret of secretsData.secrets) {
                        secrets[secret.name] = '***';
                    }

                    const variablesResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/actions/variables`, {
                        headers: { Authorization: `Bearer ${pat}`, Accept: 'application/vnd.github.v3+json' }
                    });
                    const variablesData = await variablesResponse.json();
                    const variables = {};
                    for (const variable of variablesData.variables) {
                        variables[variable.name] = variable.value;
                    }

                    const workspaceFile = contents.find(f => f.path.endsWith('.gwf') || f.path === 'workspace.json');
                    let workspace = { tabs: [], htmlElements: [], files: [], secrets: {}, variables: {} };
                    if (workspaceFile && workspaceFile.path.endsWith('.gwf')) {
                        const zip = await JSZip.loadAsync(workspaceFile.content, { base64: true });
                        const manifest = await zip.file('manifest.json')?.async('string');
                        if (manifest) workspace = JSON.parse(manifest);
                    } else if (workspaceFile && workspaceFile.path === 'workspace.json') {
                        workspace = JSON.parse(workspaceFile.content);
                        workspace.files = contents.filter(f => !f.path.endsWith('.json')).map(f => ({ path: f.path, content: f.content }));
                        workspace.secrets = secrets;
                        workspace.variables = variables;
                    } else {
                        workspace.files = contents;
                        workspace.secrets = secrets;
                        workspace.variables = variables;
                    }

                    return workspace;
                } catch (e) {
                    console.error('Import from GitHub error:', e);
                    throw e;
                }
            }

            // Placeholder for secret encryption (client-side simplified)
            async function encryptSecret(publicKey, secretValue) {
                try {
                    // Note: Proper encryption requires a library like libsodium
                    console.warn('Using simplified base64 encoding for secrets. Use server-side encryption for production.');
                    return btoa(secretValue);
                } catch (e) {
                    console.error('Encrypt secret error:', e);
                    throw e;
                }
            }

            // Export to .gwf
            async function exportToGWF() {
                try {
                    const zip = new JSZip();
                    const files = generateFiles();
                    for (const [path, content] of Object.entries(files)) {
                        zip.file(path, content);
                    }
                    zip.file('scripts/script.js', '// Example script\nconsole.log("Hello from ActionStack");');
                    zip.file('resources/style.css', '/* Example CSS */\nbody { background-color: #f0f0f0; }');
                    const manifest = {
                        tabs,
                        htmlElements,
                        secrets: { EXAMPLE_SECRET: '***' },
                        variables: { ENV: 'prod' },
                        files: Object.keys(files).map(path => ({ path, content: files[path] }))
                    };
                    zip.file('manifest.json', JSON.stringify(manifest));
                    const content = await zip.generateAsync({ type: 'base64', compression: 'DEFLATE' });
                    const a = document.createElement('a');
                    a.href = `data:application/zip;base64,${content}`;
                    a.download = 'workspace.gwf';
                    a.click();
                } catch (e) {
                    console.error('Export to GWF error:', e);
                    alert('Failed to export workspace: ' + e.message);
                }
            }

            // Import/Export buttons
            document.getElementById('export-btn')?.addEventListener('click', () => {
                try {
                    exportToGWF();
                } catch (e) {
                    console.error('Export error:', e);
                    alert('Failed to export workspace: ' + e.message);
                }
            });

            document.getElementById('import-btn')?.addEventListener('click', () => {
                try {
                    const useGitHub = confirm('Import from GitHub repository? (Click Cancel to import from a .gwf file)');
                    if (useGitHub) {
                        const pat = document.getElementById('github-pat')?.value;
                        if (!pat) {
                            alert('Please enter a GitHub PAT.');
                            return;
                        }
                        if (!validatePAT(pat)) {
                            alert('Invalid PAT format.');
                            return;
                        }
                        const repo = prompt('Enter GitHub repository (owner/repo):');
                        if (repo) {
                            importFromGitHub(pat, repo).then(workspace => {
                                tabs = workspace.tabs || [{ name: 'main.yml', blocks: [], wires: [] }];
                                htmlElements = workspace.htmlElements || [];
                                currentTab = 0;
                                updateTabs();
                                draw();
                                updateHtmlCodeEditor();
                                drawHtmlCanvas();
                                alert('Workspace imported from GitHub.');
                                document.getElementById('github-pat').value = '';
                            }).catch(e => {
                                alert('Failed to import from GitHub: ' + e.message);
                            });
                        }
                    } else {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.gwf,.json';
                        input.onchange = async (e) => {
                            try {
                                const file = e.target.files[0];
                                if (!file) return;
                                if (file.name.endsWith('.gwf')) {
                                    const reader = new FileReader();
                                    reader.onload = async (event) => {
                                        try {
                                            const zip = await JSZip.loadAsync(event.target.result);
                                            const manifest = await zip.file('manifest.json')?.async('string');
                                            if (!manifest) throw new Error('Invalid .gwf file: manifest.json missing.');
                                            const workspace = JSON.parse(manifest);
                                            tabs = workspace.tabs || [{ name: 'main.yml', blocks: [], wires: [] }];
                                            htmlElements = workspace.htmlElements || [];
                                            currentTab = 0;
                                            updateTabs();
                                            draw();
                                            updateHtmlCodeEditor();
                                            drawHtmlCanvas();
                                            alert('Workspace imported from .gwf file.');
                                        } catch (e) {
                                            console.error('Import GWF parse error:', e);
                                            alert('Failed to import .gwf file: ' + e.message);
                                        }
                                    };
                                    reader.readAsArrayBuffer(file);
                                } else if (file.name.endsWith('.json')) {
                                    const reader = new FileReader();
                                    reader.onload = (event) => {
                                        try {
                                            const workspace = JSON.parse(event.target.result);
                                            tabs = workspace.tabs || [{ name: 'main.yml', blocks: [], wires: [] }];
                                            htmlElements = workspace.htmlElements || [];
                                            currentTab = 0;
                                            updateTabs();
                                            draw();
                                            updateHtmlCodeEditor();
                                            drawHtmlCanvas();
                                            alert('Workspace imported from .json file.');
                                        } catch (e) {
                                            console.error('Import JSON parse error:', e);
                                            alert('Failed to import .json file: ' + e.message);
                                        }
                                    };
                                    reader.readAsText(file);
                                }
                            } catch (e) {
                                console.error('Import file error:', e);
                                alert('Failed to import workspace: ' + e.message);
                            }
                        };
                        input.click();
                    }
                } catch (e) {
                    console.error('Import error:', e);
                    alert('Failed to import workspace: ' + e.message);
                }
            });

            document.getElementById('save-btn')?.addEventListener('click', () => {
                try {
                    const pat = document.getElementById('github-pat')?.value;
                    if (!pat) {
                        alert('Please enter a GitHub PAT. For security, create a PAT with an expiration date.');
                        return;
                    }
                    if (!validatePAT(pat)) {
                        alert('Invalid PAT format.');
                        return;
                    }
                    const repo = prompt('Enter GitHub repository (owner/repo):');
                    if (repo) {
                        const files = generateFiles();
                        files['scripts/script.js'] = '// Example script\nconsole.log("Hello from ActionStack");';
                        files['resources/style.css'] = '/* Example CSS */\nbody { background-color: #f0f0f0; }';
                        const secrets = { EXAMPLE_SECRET: 'example_value' };
                        const variables = { ENV: 'prod' };
                        saveToGitHub(pat, repo, files, secrets, variables).then(() => {
                            alert('Workspace saved to GitHub.');
                            document.getElementById('github-pat').value = '';
                        }).catch(e => {
                            alert('Failed to save to GitHub: ' + e.message);
                        });
                    }
                } catch (e) {
                    console.error('Save error:', e);
                    alert('Failed to save workspace: ' + e.message);
                }
            });

            // Initialize
            updateTabs();
            draw();
            updateHtmlCodeEditor();
            drawHtmlCanvas();
        });
    </script>
</body>
</html>
