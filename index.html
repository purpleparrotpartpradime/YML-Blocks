<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ActionStack IDE</title>
    <style>
        /* Minimal Tailwind CSS subset with responsive utilities */
        .flex { display: flex; }
        .flex-1 { flex: 1 1 0%; }
        .flex-col { flex-direction: column; }
        .flex-row { flex-direction: row; }
        .justify-between { justify-content: space-between; }
        .items-center { align-items: center; }
        .space-x-2 > * + * { margin-left: 0.5rem; }
        .space-x-1 > * + * { margin-left: 0.25rem; }
        .space-y-2 > * + * { margin-top: 0.5rem; }
        .h-screen { height: 100vh; }
        .w-64 { width: 16rem; }
        .w-full { width: 100%; }
        .w-[120px] { width: 120px; }
        .h-10 { height: 2.5rem; }
        .max-w-[280px] { max-width: 280px; }
        .max-h-[80vh] { max-height: 80vh; }
        .p-4 { padding: 1rem; }
        .p-2 { padding: 0.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mt-2 { margin-top: 0.5rem; }
        .bg-gray-800 { background-color: #1f2937; }
        .bg-gray-700 { background-color: #374151; }
        .bg-blue-600 { background-color: #2563eb; }
        .bg-blue-700 { background-color: #1d4ed8; }
        .bg-opacity-50 { background-color: rgba(0, 0, 0, 0.5); }
        .text-white { color: #ffffff; }
        .text-blue-300 { color: #93c5fd; }
        .text-gray-300 { color: #d1d5db; }
        .text-lg { font-size: 1.125rem; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .rounded { border-radius: 0.25rem; }
        .overflow-y-auto { overflow-y: auto; }
        .hidden { display: none; }
        .cursor-pointer { cursor: pointer; }
        .cursor-move { cursor: move; }
        .opacity-75 { opacity: 0.75; }
        .hover\:bg-blue-700:hover { background-color: #1d4ed8; }
        .fixed { position: fixed; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .z-20 { z-index: 20; }
        .z-30 { z-index: 30; }
        .sm\:p-4 { padding: 1rem; }
        .sm\:text-lg { font-size: 1.125rem; }
        .sm\:text-sm { font-size: 0.875rem; }
        .sm\:w-64 { width: 16rem; }
        .sm\:flex-row { flex-direction: row; }
        .md\:p-4 { padding: 1rem; }
        .touch-pan-y { touch-action: pan-y; }

        /* Custom styles for the IDE */
        body { background-color: #1a1a1a; color: #e5e7eb; font-family: Arial, sans-serif; margin: 0; }
        #canvas, #html-canvas { border: 1px solid #4b5563; background-color: #2d2d2d; width: 100%; }
        .block { border-radius: 8px; padding: 8px; }
        .toolbar .block { display: flex; align-items: center; justify-content: center; }
        .node { width: 12px; height: 12px; border-radius: 50%; position: absolute; }
        .input-node { background-color: #3b82f6; }
        .output-node { background-color: #ef4444; }
        .toolbar { background-color: #374151; z-index: 30; }
        .tab { background-color: #4b5563; }
        .tab.active { background-color: #3b82f6; }
        .wire { stroke: #60a5fa; stroke-width: 2; }
        @media (max-width: 640px) {
            .toolbar { position: fixed; top: 0; left: -100%; width: 75%; max-width: 280px; height: 100%; transition: left 0.3s; }
            .toolbar.open { left: 0; }
            .overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); z-index: 20; }
            .canvas-container { margin-left: 0; }
            .node { width: 16px; height: 16px; }
            .block { padding: 6px; }
            .toolbar .block { padding: 8px; }
            #toggle-toolbar { z-index: 30; }
            #yaml-blocks, #html-elements { max-height: calc(100vh - 80px); }
        }
        @media (min-width: 640px) {
            #yaml-blocks, #html-elements { max-height: calc(100vh - 120px); }
        }
    </style>
</head>
<body class="flex h-screen flex-col sm:flex-row">
    <button id="toggle-toolbar" class="fixed top-2 left-2 sm:hidden px-2 py-1 bg-blue-600 text-white text-sm rounded z-30">â˜°</button>
    <div id="toolbar" class="toolbar sm:w-64 p-2 sm:p-4 overflow-y-auto touch-pan-y">
        <div class="flex justify-between items-center mb-2">
            <h2 class="text-sm sm:text-lg font-bold text-blue-300">Toolbar</h2>
            <button id="close-toolbar" class="sm:hidden px-2 py-1 bg-blue-600 text-white text-sm rounded hidden">Close</button>
        </div>
        <div id="yaml-blocks" class="mb-4 overflow-y-auto touch-pan-y">
            <h3 class="text-xs sm:text-sm font-semibold text-gray-300">YAML Blocks</h3>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="AND">AND Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="XOR">XOR Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="NOR">NOR Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="EITHER">EITHER Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="MATH">Math Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="VARIABLE">Variable Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CALC_METHOD">Calc Method Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_HTML">Custom HTML Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_JAVA">Custom Java Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_NODEJS">Custom Node.js Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_JS">Custom JS Block</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="CUSTOM_YAML">Custom YAML Block</div>
        </div>
        <div id="html-elements" class="hidden overflow-y-auto touch-pan-y">
            <h3 class="text-xs sm:text-sm font-semibold text-gray-300">HTML Elements</h3>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="DIV">Div Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="BUTTON">Button Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="INPUT">Input Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="P">Paragraph Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="H1">Heading 1 Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="IMG">Image Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="A">Link Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="SPAN">Span Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="UL">Unordered List Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="LI">List Item Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="FORM">Form Element</div>
            <div class="block bg-gray-700 text-white text-xs sm:text-sm mb-2 cursor-move w-[120px] h-10 rounded" draggable="true" data-type="TEXTAREA">Textarea Element</div>
        </div>
    </div>
    <div id="overlay" class="hidden overlay"></div>
    <div class="flex-1 flex flex-col canvas-container">
        <div class="flex flex-col sm:flex-row justify-between p-2 sm:p-4 bg-gray-800">
            <div class="flex space-x-2">
                <button id="yaml-tab" class="tab px-2 sm:px-4 py-1 sm:py-2 text-white text-xs sm:text-sm active">YAML Editor</button>
                <button id="html-tab" class="tab px-2 sm:px-4 py-1 sm:py-2 text-white text-xs sm:text-sm">HTML Editor</button>
            </div>
            <div class="flex space-x-2 mt-2 sm:mt-0">
                <input id="github-pat" type="password" placeholder="GitHub PAT" class="px-2 py-1 bg-gray-700 text-white text-xs sm:text-sm rounded w-full sm:w-auto">
                <button id="import-btn" class="px-2 sm:px-4 py-1 sm:py-2 bg-blue-600 text-white text-xs sm:text-sm rounded hover:bg-blue-700">Import</button>
                <button id="export-btn" class="px-2 sm:px-4 py-1 sm:py-2 bg-blue-600 text-white text-xs sm:text-sm rounded hover:bg-blue-700">Export</button>
                <button id="save-btn" class="px-2 sm:px-4 py-1 sm:py-2 bg-blue-600 text-white text-xs sm:text-sm rounded hover:bg-blue-700">Save to GitHub</button>
            </div>
        </div>
        <div id="yaml-editor" class="flex-1 p-2 sm:p-4">
            <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 mb-4">
                <button id="new-tab-btn" class="px-2 py-1 bg-gray-700 text-white text-xs sm:text-sm rounded">New Tab</button>
                <div id="tab-bar" class="flex space-x-1"></div>
            </div>
            <canvas id="canvas"></canvas>
        </div>
        <div id="html-editor" class="flex-1 p-2 sm:p-4 hidden">
            <canvas id="html-canvas"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas');
            const ctx = canvas?.getContext('2d');
            const htmlCanvas = document.getElementById('html-canvas');
            const htmlCtx = htmlCanvas?.getContext('2d');
            let blocks = [];
            let htmlElements = [];
            let wires = [];
            let tabs = [{ name: 'main.yml', blocks: [], wires: [] }];
            let currentTab = 0;
            let draggingBlock = null;
            let draggingWire = null;
            let offsetX, offsetY;
            let activeTab = 'yaml';
            let touchStartTime = 0;

            // Block definitions
            const blockTypes = {
                AND: { inputs: 2, outputs: 1, color: '#4b5563', height: 80 },
                XOR: { inputs: 2, outputs: 1, color: '#4b5563', height: 80 },
                NOR: { inputs: 2, outputs: 1, color: '#4b5563', height: 80 },
                EITHER: { inputs: 2, outputs: 1, color: '#4b5563', height: 80 },
                MATH: { inputs: 2, outputs: 1, color: '#4b5563', height: 100 },
                VARIABLE: { inputs: 1, outputs: 1, color: '#4b5563', height: 60 },
                CALC_METHOD: { inputs: 0, outputs: 1, color: '#4b5563', height: 60 },
                CUSTOM_HTML: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 },
                CUSTOM_JAVA: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 },
                CUSTOM_NODEJS: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 },
                CUSTOM_JS: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 },
                CUSTOM_YAML: { inputs: 0, outputs: 1, color: '#4b5563', height: 120 }
            };

            // HTML element types for validation
            const htmlElementTypes = ['DIV', 'BUTTON', 'INPUT', 'P', 'H1', 'IMG', 'A', 'SPAN', 'UL', 'LI', 'FORM', 'TEXTAREA'];

            // Responsive canvas sizing
            function resizeCanvases() {
                try {
                    const container = document.querySelector('.canvas-container');
                    if (!container || !canvas || !htmlCanvas) return;
                    const width = container.clientWidth - (window.innerWidth < 640 ? 16 : 32);
                    const height = container.clientHeight - (window.innerWidth < 640 ? 150 : 100);
                    canvas.width = width;
                    canvas.height = height;
                    htmlCanvas.width = width;
                    htmlCanvas.height = height;
                    draw();
                    drawHtmlCanvas();
                } catch (e) {
                    console.error('Canvas resize error:', e);
                }
            }

            window.addEventListener('resize', resizeCanvases);

            // Toolbar toggle for mobile
            const toolbar = document.getElementById('toolbar');
            const toggleToolbarBtn = document.getElementById('toggle-toolbar');
            const closeToolbarBtn = document.getElementById('close-toolbar');
            const overlay = document.getElementById('overlay');

            function closeToolbar() {
                try {
                    if (toolbar && closeToolbarBtn && toggleToolbarBtn && overlay) {
                        toolbar.classList.remove('open');
                        closeToolbarBtn.classList.add('hidden');
                        toggleToolbarBtn.classList.remove('hidden');
                        overlay.classList.add('hidden');
                    }
                } catch (e) {
                    console.error('Close toolbar error:', e);
                }
            }

            if (toggleToolbarBtn) {
                toggleToolbarBtn.addEventListener('click', () => {
                    try {
                        if (toolbar && closeToolbarBtn && toggleToolbarBtn && overlay) {
                            toolbar.classList.add('open');
                            closeToolbarBtn.classList.remove('hidden');
                            toggleToolbarBtn.classList.add('hidden');
                            overlay.classList.remove('hidden');
                        }
                    } catch (e) {
                        console.error('Toggle toolbar error:', e);
                    }
                });
            }

            if (closeToolbarBtn) closeToolbarBtn.addEventListener('click', closeToolbar);
            if (overlay) overlay.addEventListener('click', closeToolbar);

            // Initialize toolbar block events
            document.querySelectorAll('.block').forEach(block => {
                block.addEventListener('dragstart', (e) => {
                    try {
                        e.dataTransfer.setData('type', block.dataset.type);
                        block.classList.add('opacity-75');
                        if (window.innerWidth < 640) closeToolbar();
                    } catch (e) {
                        console.error('Block dragstart error:', e);
                    }
                });
                block.addEventListener('dragend', () => {
                    try {
                        block.classList.remove('opacity-75');
                    } catch (e) {
                        console.error('Block dragend error:', e);
                    }
                });
                block.addEventListener('touchstart', (e) => {
                    try {
                        touchStartTime = Date.now();
                    } catch (e) {
                        console.error('Block touchstart error:', e);
                    }
                });
                block.addEventListener('touchend', (e) => {
                    try {
                        if (Date.now() - touchStartTime < 300 && !block.classList.contains('opacity-75')) {
                            block.click();
                        }
                    } catch (e) {
                        console.error('Block touchend error:', e);
                    }
                });
                block.addEventListener('click', () => {
                    try {
                        const type = block.dataset.type;
                        const targetCanvas = activeTab === 'yaml' ? canvas : htmlCanvas;
                        if (!targetCanvas) return;
                        const blockWidth = activeTab === 'yaml' ? (window.innerWidth < 640 ? 150 : 200) : (window.innerWidth < 640 ? 100 : 150);
                        const blockHeight = activeTab === 'yaml' ? blockTypes[type]?.height || 60 : 50;
                        const x = targetCanvas.width / 2 - blockWidth / 2;
                        const y = targetCanvas.height / 2 - blockHeight / 2;
                        if (activeTab === 'yaml' && blockTypes[type]) {
                            const newBlock = {
                                id: Date.now(),
                                type,
                                x,
                                y,
                                inputs: blockTypes[type].inputs,
                                outputs: blockTypes[type].outputs,
                                value: type === 'VARIABLE' ? 0 : (type === 'CALC_METHOD' ? 'add' : ''),
                                htmlElement: null
                            };
                            tabs[currentTab].blocks.push(newBlock);
                            draw();
                        } else if (activeTab === 'html' && htmlElementTypes.includes(type)) {
                            const element = {
                                id: Date.now(),
                                type,
                                x,
                                y,
                                content: type === 'IMG' ? 'image.png' : type === 'A' ? { text: 'Link', href: '#' } : type.toLowerCase()
                            };
                            htmlElements.push(element);
                            drawHtmlCanvas();
                        }
                        if (window.innerWidth < 640) closeToolbar();
                    } catch (e) {
                        console.error('Block click error:', e);
                    }
                });
            });

            // Canvas drag-and-drop
            function getCanvasPosition(e, canvas, isTouch = false) {
                try {
                    if (!canvas) return { x: 0, y: 0 };
                    const rect = canvas.getBoundingClientRect();
                    const clientX = isTouch ? (e.touches?.[0]?.clientX || e.changedTouches?.[0]?.clientX || e.clientX || 0) : e.clientX;
                    const clientY = isTouch ? (e.touches?.[0]?.clientY || e.changedTouches?.[0]?.clientY || e.clientY || 0) : e.clientY;
                    return { x: clientX - rect.left, y: clientY - rect.top };
                } catch (e) {
                    console.error('getCanvasPosition error:', e);
                    return { x: 0, y: 0 };
                }
            }

            if (canvas) {
                canvas.addEventListener('dragover', (e) => e.preventDefault());
                canvas.addEventListener('drop', (e) => {
                    try {
                        e.preventDefault();
                        const type = e.dataTransfer.getData('type');
                        if (blockTypes[type]) {
                            const { x, y } = getCanvasPosition(e, canvas);
                            const block = {
                                id: Date.now(),
                                type,
                                x,
                                y,
                                inputs: blockTypes[type].inputs,
                                outputs: blockTypes[type].outputs,
                                value: type === 'VARIABLE' ? 0 : (type === 'CALC_METHOD' ? 'add' : ''),
                                htmlElement: null
                            };
                            tabs[currentTab].blocks.push(block);
                            draw();
                        }
                    } catch (e) {
                        console.error('Canvas drop error:', e);
                    }
                });
            }

            if (htmlCanvas) {
                htmlCanvas.addEventListener('dragover', (e) => e.preventDefault());
                htmlCanvas.addEventListener('drop', (e) => {
                    try {
                        e.preventDefault();
                        const type = e.dataTransfer.getData('type');
                        if (htmlElementTypes.includes(type)) {
                            const { x, y } = getCanvasPosition(e, htmlCanvas);
                            const element = {
                                id: Date.now(),
                                type,
                                x,
                                y,
                                content: type === 'IMG' ? 'image.png' : type === 'A' ? { text: 'Link', href: '#' } : type.toLowerCase()
                            };
                            htmlElements.push(element);
                            drawHtmlCanvas();
                        }
                    } catch (e) {
                        console.error('HTML canvas drop error:', e);
                    }
                });
            }

            // Mouse and touch events for dragging blocks and wires
            function handleStart(e, isTouch = false) {
                try {
                    if (isTouch && !e.touches?.length) return;
                    const { x, y } = getCanvasPosition(isTouch ? e : e, canvas, isTouch);
                    for (let block of tabs[currentTab].blocks) {
                        const blockWidth = window.innerWidth < 640 ? 150 : 200;
                        const blockHeight = blockTypes[block.type]?.height || 60;
                        if (x >= block.x && x <= block.x + blockWidth && y >= block.y && y <= block.y + blockHeight) {
                            const node = getNode(block, x, y);
                            if (node) {
                                draggingWire = { block, node };
                                return;
                            }
                            draggingBlock = block;
                            offsetX = x - block.x;
                            offsetY = y - block.y;
                            break;
                        }
                    }
                } catch (e) {
                    console.error('Canvas handleStart error:', e);
                }
            }

            function handleMove(e, isTouch = false) {
                try {
                    if (isTouch && !e.touches?.length) return;
                    const { x, y } = getCanvasPosition(isTouch ? e : e, canvas, isTouch);
                    if (draggingBlock) {
                        draggingBlock.x = x - offsetX;
                        draggingBlock.y = y - offsetY;
                        draw();
                    } else if (draggingWire && ctx) {
                        draw();
                        ctx.beginPath();
                        ctx.moveTo(draggingWire.node.x, draggingWire.node.y);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = '#60a5fa';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                } catch (e) {
                    console.error('Canvas handleMove error:', e);
                }
            }

            function handleEnd(e, isTouch = false) {
                try {
                    if (draggingWire) {
                        const { x, y } = getCanvasPosition(isTouch ? (e.changedTouches?.[0] || e) : e, canvas, isTouch);
                        let closestNode = null;
                        let minDistance = Infinity;
                        let targetBlock = null;
                        console.log(`Drop coordinates: x=${x}, y=${y}`);
                        for (let block of tabs[currentTab].blocks) {
                            if (block !== draggingWire.block) {
                                const node = getNode(block, x, y, true);
                                if (node && node.type === 'input') {
                                    const distance = Math.hypot(x - node.x, y - node.y);
                                    console.log(`Checking block ${block.id}, input ${node.index}: distance=${distance}`);
                                    if (distance < minDistance) {
                                        minDistance = distance;
                                        closestNode = node;
                                        targetBlock = block;
                                    }
                                }
                            }
                        }
                        const maxDistance = window.innerWidth < 640 ? 30 : 25;
                        if (closestNode && targetBlock && draggingWire.node.type === 'output' && minDistance < maxDistance) {
                            console.log(`Connecting wire from block ${draggingWire.block.id} output ${draggingWire.node.index} to block ${targetBlock.id} input ${closestNode.index}`);
                            tabs[currentTab].wires.push({
                                from: { block: draggingWire.block, index: draggingWire.node.index },
                                to: { block: targetBlock, index: closestNode.index }
                            });
                        } else {
                            console.log(`No valid input node found within ${maxDistance}px: minDistance=${minDistance}`);
                        }
                        draggingWire = null;
                        draw();
                    }
                    draggingBlock = null;
                } catch (e) {
                    console.error('Canvas handleEnd error:', e);
                }
            }

            if (canvas) {
                canvas.addEventListener('mousedown', handleStart);
                canvas.addEventListener('mousemove', handleMove);
                canvas.addEventListener('mouseup', handleEnd);
                canvas.addEventListener('touchstart', (e) => {
                    try {
                        touchStartTime = Date.now();
                        handleStart(e, true);
                    } catch (e) {
                        console.error('Canvas touchstart error:', e);
                    }
                });
                canvas.addEventListener('touchmove', (e) => handleMove(e, true));
                canvas.addEventListener('touchend', (e) => {
                    try {
                        if (Date.now() - touchStartTime < 300 && !draggingWire && !draggingBlock) {
                            return;
                        }
                        handleEnd(e, true);
                    } catch (e) {
                        console.error('Canvas touchend error:', e);
                    }
                });
            }

            function isNearNode(block, x, y) {
                try {
                    const nodeSize = window.innerWidth < 640 ? 10 : 8;
                    const hitbox = window.innerWidth < 640 ? 30 : 25;
                    for (let i = 0; i < block.inputs; i++) {
                        const nodeX = block.x;
                        const nodeY = block.y + 20 + i * 30;
                        if (Math.hypot(x - nodeX, y - nodeY) < hitbox) return true;
                    }
                    for (let i = 0; i < block.outputs; i++) {
                        const nodeX = block.x + (window.innerWidth < 640 ? 150 : 200);
                        const nodeY = block.y + 20 + i * 30;
                        if (Math.hypot(x - nodeX, y - nodeY) < hitbox) return true;
                    }
                    return false;
                } catch (e) {
                    console.error('isNearNode error:', e);
                    return false;
                }
            }

            function getNode(block, x, y, inputOnly = false) {
                try {
                    if (!block) return null;
                    const nodeSize = window.innerWidth < 640 ? 10 : 8;
                    const hitbox = window.innerWidth < 640 ? 30 : 25; // Increased hitbox for easier dropping
                    for (let i = 0; i < block.inputs; i++) {
                        const nodeX = block.x;
                        const nodeY = block.y + 20 + i * 30;
                        if (Math.hypot(x - nodeX, y - nodeY) < hitbox) {
                            return { x: nodeX, y: nodeY, type: 'input', index: i };
                        }
                    }
                    if (!inputOnly) {
                        for (let i = 0; i < block.outputs; i++) {
                            const nodeX = block.x + (window.innerWidth < 640 ? 150 : 200);
                            const nodeY = block.y + 20 + i * 30;
                            if (Math.hypot(x - nodeX, y - nodeY) < hitbox) {
                                return { x: nodeX, y: nodeY, type: 'output', index: i };
                            }
                        }
                    }
                    return null;
                } catch (e) {
                    console.error('getNode error:', e);
                    return null;
                }
            }

            function draw() {
                try {
                    if (!ctx || !canvas) return;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const blockWidth = window.innerWidth < 640 ? 150 : 200;
                    // Draw wires
                    for (let wire of tabs[currentTab].wires) {
                        const fromNodeX = wire.from.block.x + blockWidth;
                        const fromNodeY = wire.from.block.y + 20 + wire.from.index * 30;
                        const toNodeX = wire.to.block.x;
                        const toNodeY = wire.to.block.y + 20 + wire.to.index * 30;
                        ctx.beginPath();
                        ctx.moveTo(fromNodeX, fromNodeY);
                        ctx.lineTo(toNodeX, toNodeY);
                        ctx.strokeStyle = '#60a5fa';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    // Draw blocks
                    for (let block of tabs[currentTab].blocks) {
                        ctx.fillStyle = blockTypes[block.type]?.color || '#4b5563';
                        ctx.fillRect(block.x, block.y, blockWidth, blockTypes[block.type]?.height || 60);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = window.innerWidth < 640 ? '12px Arial' : '14px Arial';
                        ctx.fillText(block.type, block.x + 10, block.y + 20);
                        if (block.type === 'VARIABLE') {
                            ctx.fillText(`Value: ${block.value}`, block.x + 10, block.y + 40);
                        } else if (block.type === 'CALC_METHOD') {
                            ctx.fillText(`Method: ${block.value}`, block.x + 10, block.y + 40);
                        }
                        // Draw input nodes
                        for (let i = 0; i < block.inputs; i++) {
                            ctx.beginPath();
                            ctx.arc(block.x, block.y + 20 + i * 30, window.innerWidth < 640 ? 10 : 8, 0, Math.PI * 2);
                            ctx.fillStyle = '#3b82f6';
                            ctx.fill();
                        }
                        // Draw output nodes
                        for (let i = 0; i < block.outputs; i++) {
                            ctx.beginPath();
                            ctx.arc(block.x + blockWidth, block.y + 20 + i * 30, window.innerWidth < 640 ? 10 : 8, 0, Math.PI * 2);
                            ctx.fillStyle = '#ef4444';
                            ctx.fill();
                        }
                    }
                } catch (e) {
                    console.error('Draw error:', e);
                }
            }

            function drawHtmlCanvas() {
                try {
                    if (!htmlCtx || !htmlCanvas) return;
                    htmlCtx.clearRect(0, 0, htmlCanvas.width, htmlCanvas.height);
                    const blockWidth = window.innerWidth < 640 ? 100 : 150;
                    for (let element of htmlElements) {
                        htmlCtx.fillStyle = '#4b5563';
                        htmlCtx.fillRect(element.x, element.y, blockWidth, 50);
                        htmlCtx.fillStyle = '#ffffff';
                        htmlCtx.font = window.innerWidth < 640 ? '12px Arial' : '14px Arial';
                        let displayText = element.type;
                        if (element.type === 'IMG') displayText += ` (src: ${element.content})`;
                        else if (element.type === 'A') displayText = `Link (href: ${element.content.href})`;
                        else displayText = element.content;
                        htmlCtx.fillText(displayText, element.x + 10, element.y + 30);
                    }
                } catch (e) {
                    console.error('Draw HTML canvas error:', e);
                }
            }

            // Tab switching
            function switchToYamlTab() {
                try {
                    activeTab = 'yaml';
                    const yamlEditor = document.getElementById('yaml-editor');
                    const htmlEditor = document.getElementById('html-editor');
                    const yamlBlocks = document.getElementById('yaml-blocks');
                    const htmlElementsDiv = document.getElementById('html-elements');
                    const yamlTab = document.getElementById('yaml-tab');
                    const htmlTab = document.getElementById('html-tab');
                    if (yamlEditor) yamlEditor.classList.remove('hidden');
                    if (htmlEditor) htmlEditor.classList.add('hidden');
                    if (yamlBlocks) yamlBlocks.classList.remove('hidden');
                    if (htmlElementsDiv) htmlElementsDiv.classList.add('hidden');
                    if (yamlTab) yamlTab.classList.add('active');
                    if (htmlTab) htmlTab.classList.remove('active');
                    if (window.innerWidth < 640) closeToolbar();
                    draw();
                } catch (e) {
                    console.error('Switch to YAML tab error:', e);
                }
            }

            function switchToHtmlTab() {
                try {
                    activeTab = 'html';
                    const yamlEditor = document.getElementById('yaml-editor');
                    const htmlEditor = document.getElementById('html-editor');
                    const yamlBlocks = document.getElementById('yaml-blocks');
                    const htmlElementsDiv = document.getElementById('html-elements');
                    const yamlTab = document.getElementById('yaml-tab');
                    const htmlTab = document.getElementById('html-tab');
                    if (yamlEditor) yamlEditor.classList.add('hidden');
                    if (htmlEditor) htmlEditor.classList.remove('hidden');
                    if (yamlBlocks) yamlBlocks.classList.add('hidden');
                    if (htmlElementsDiv) htmlElementsDiv.classList.remove('hidden');
                    if (yamlTab) yamlTab.classList.remove('active');
                    if (htmlTab) htmlTab.classList.add('active');
                    if (window.innerWidth < 640) closeToolbar();
                    drawHtmlCanvas();
                } catch (e) {
                    console.error('Switch to HTML tab error:', e);
                }
            }

            const yamlTabBtn = document.getElementById('yaml-tab');
            const htmlTabBtn = document.getElementById('html-tab');
            if (yamlTabBtn) yamlTabBtn.addEventListener('click', switchToYamlTab);
            if (htmlTabBtn) htmlTabBtn.addEventListener('click', switchToHtmlTab);

            // Tab management
            function updateTabs() {
                try {
                    const tabBar = document.getElementById('tab-bar');
                    if (!tabBar) return;
                    tabBar.innerHTML = '';
                    tabs.forEach((tab, index) => {
                        const tabEl = document.createElement('div');
                        tabEl.className = `px-2 py-1 bg-gray-700 text-white text-xs sm:text-sm rounded cursor-pointer ${index === currentTab ? 'bg-blue-600' : ''}`;
                        tabEl.textContent = tab.name;
                        tabEl.addEventListener('click', () => {
                            currentTab = index;
                            updateTabs();
                            draw();
                        });
                        tabBar.appendChild(tabEl);
                    });
                } catch (e) {
                    console.error('Update tabs error:', e);
                }
            }

            const newTabBtn = document.getElementById('new-tab-btn');
            if (newTabBtn) {
                newTabBtn.addEventListener('click', () => {
                    try {
                        const name = prompt('Enter tab name:', `file${tabs.length + 1}.yml`);
                        if (name) {
                            tabs.push({ name, blocks: [], wires: [] });
                            currentTab = tabs.length - 1;
                            updateTabs();
                            draw();
                        }
                    } catch (e) {
                        console.error('New tab error:', e);
                    }
                });
            }

            // Import/Export
            const exportBtn = document.getElementById('export-btn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    try {
                        const workspace = { tabs, htmlElements };
                        const blob = new Blob([JSON.stringify(workspace)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'workspace.json';
                        a.click();
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        console.error('Export error:', e);
                    }
                });
            }

            const importBtn = document.getElementById('import-btn');
            if (importBtn) {
                importBtn.addEventListener('click', () => {
                    try {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.json';
                        input.onchange = (e) => {
                            try {
                                const file = e.target.files[0];
                                if (!file) return;
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    try {
                                        const workspace = JSON.parse(event.target.result);
                                        tabs = workspace.tabs || [{ name: 'main.yml', blocks: [], wires: [] }];
                                        htmlElements = workspace.htmlElements || [];
                                        currentTab = 0;
                                        updateTabs();
                                        draw();
                                        drawHtmlCanvas();
                                    } catch (e) {
                                        console.error('Import parse error:', e);
                                    }
                                };
                                reader.readAsText(file);
                            } catch (e) {
                                console.error('Import file error:', e);
                            }
                        };
                        input.click();
                    } catch (e) {
                        console.error('Import error:', e);
                    }
                });
            }

            // Save to GitHub (mock)
            const saveBtn = document.getElementById('save-btn');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    try {
                        const pat = document.getElementById('github-pat')?.value;
                        if (!pat) {
                            alert('Please enter a GitHub PAT.');
                            return;
                        }
                        const repo = prompt('Enter GitHub repository (owner/repo):');
                        if (repo) {
                            console.log('Simulating save to GitHub repo:', repo);
                            console.log('Generated files:', generateFiles());
                            alert('Workspace saved to GitHub (simulated). Opening repo...');
                            window.open(`https://github.com/${repo}`, '_blank');
                            document.getElementById('github-pat').value = '';
                        }
                    } catch (e) {
                        console.error('Save to GitHub error:', e);
                    }
                });
            }

            function generateFiles() {
                try {
                    const files = {};
                    tabs.forEach(tab => {
                        files[tab.name] = generateYAML(tab);
                    });
                    files['index.html'] = generateHTML();
                    return files;
                } catch (e) {
                    console.error('Generate files error:', e);
                    return {};
                }
            }

            function generateYAML(tab) {
                try {
                    let yaml = `name: ${tab.name}\nsteps:\n`;
                    tab.blocks.forEach(block => {
                        yaml += `  - id: ${block.id}\n    type: ${block.type}\n`;
                        if (block.value) yaml += `    value: ${block.value}\n`;
                        const connections = tab.wires.filter(w => w.from.block.id === block.id);
                        if (connections.length) {
                            yaml += `    outputs:\n`;
                            connections.forEach(w => {
                                yaml += `      - to: ${w.to.block.id}\n        input: ${w.to.index}\n`;
                            });
                        }
                    });
                    return yaml;
                } catch (e) {
                    console.error('Generate YAML error:', e);
                    return '';
                }
            }

            function generateHTML() {
                try {
                    let html = `<!DOCTYPE html>\n<html>\n<body>\n`;
                    htmlElements.forEach(el => {
                        if (el.type === 'IMG') {
                            html += `<${el.type.toLowerCase()} src="${el.content}">\n`;
                        } else if (el.type === 'A') {
                            html += `<${el.type.toLowerCase()} href="${el.content.href}">${el.content.text}</${el.type.toLowerCase()}>\n`;
                        } else {
                            html += `<${el.type.toLowerCase()}>${el.content}</${el.type.toLowerCase()}>\n`;
                        }
                    });
                    html += `</body>\n</html>`;
                    return html;
                } catch (e) {
                    console.error('Generate HTML error:', e);
                    return '';
                }
            }

            // Initialize
            try {
                resizeCanvases();
                updateTabs();
                draw();
                drawHtmlCanvas();
            } catch (e) {
                console.error('Initialization error:', e);
            }
        });
    </script>
</body>
</html>
